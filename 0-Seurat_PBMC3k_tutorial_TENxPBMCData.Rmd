---
title: "Seurat PBMC 3k tutorial using TENxPBMCData"
author: "Kevin Rue-Albrecht"
date: "`r BiocStyle::doc_date()`"
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
knitr::opts_chunk$set(cache=FALSE)
stopifnot({
    require(BiocStyle)
})
```

# Overview

In this example, we use count data for 2,700 peripheral blood mononuclear cells (PBMC) obtained using the [10X Genomics](www.10xgenomics.com) platform, and process it following the [Guided Clustering Tutorial](https://satijalab.org/seurat/v3.0/pbmc3k_tutorial.html) of the `r CRANpkg("Seurat")` package.

# Getting the data

First, fetch the data as a `r Biocpkg("SingleCellExperiment")` object using the `r Biocpkg("TENxPBMCData")` package.
The first time that the following code chunk is run, users should expect it to take additional time as it downloads data from the web and caches it on their local machine; subsequent evaluations of the same code chunk should only take a few seconds as the data set is then loaded from the local cache.

```{r, message=FALSE}
library(TENxPBMCData)
tenx_pbmc3k <- TENxPBMCData(dataset="pbmc3k")
colnames(tenx_pbmc3k) <- paste0("Cell", seq_len(ncol(tenx_pbmc3k)))
tenx_pbmc3k
```

# Preparing the data

Next, prepare a sparse matrix that emulates the first section of the [Guided Clustering Tutorial](https://satijalab.org/seurat/v3.0/pbmc3k_tutorial.html).

```{r, message=FALSE}
library(Matrix)
pbmc.data <- as(counts(tenx_pbmc3k), "Matrix")
pbmc.data <- as(pbmc.data, "dgTMatrix")
```

# Seurat - Guided Clustering Tutorial

From here on, follow the [Guided Clustering Tutorial](https://satijalab.org/seurat/v3.0/pbmc3k_tutorial.html) to the letter (code obtained on 2018-11-24).

```{r, message=FALSE}
library(Seurat)
library(dplyr)
# Initialize the Seurat object with the raw (non-normalized data).  Keep all
# genes expressed in >= 3 cells (~0.1% of the data). Keep all cells with at
# least 200 detected genes
pbmc <- CreateSeuratObject(counts = pbmc.data, project = "pbmc3k", min.cells = 3, min.features = 200)
pbmc
```

```{r}
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
```

```{r}
# Visualize QC metrics as a violin plot
VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
```

```{r}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.

plot1 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
CombinePlots(plots = list(plot1, plot2))
```

```{r}
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
```

```{r}
pbmc <- NormalizeData(pbmc, normalization.method = "LogNormalize", scale.factor = 10000)
```

```{r}
pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(pbmc), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
CombinePlots(plots = list(plot1, plot2))
```

```{r}
all.genes <- rownames(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes)
```

```{r}
pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))
```

```{r}
# Examine and visualize PCA results a few different ways
print(pbmc[["pca"]], dims = 1:5, nfeatures = 5)
```

```{r}
VizDimLoadings(pbmc, dims = 1:2, reduction = "pca")
```

```{r}
DimPlot(pbmc, reduction = "pca")
```

```{r}
DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE)
```

```{r}
DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE)
```

Small deviation from the tutorial. Skip the lengthy JackStraw computation.

```{r}
if (FALSE) {
    # NOTE: This process can take a long time for big datasets, comment out for expediency. More
    # approximate techniques such as those implemented in ElbowPlot() can be used to reduce
    # computation time
    pbmc <- JackStraw(pbmc, num.replicate = 100)
    pbmc <- ScoreJackStraw(pbmc, dims = 1:20)
    JackStrawPlot(pbmc, dims = 1:15)
}
```

```{r}
ElbowPlot(pbmc)
```

```{r}
pbmc <- FindNeighbors(pbmc, dims = 1:10)
pbmc <- FindClusters(pbmc, resolution = 0.5)
# Look at cluster IDs of the first 5 cells
head(Idents(pbmc), 5)
```

```{r}
# If you haven't installed UMAP, you can do so via reticulate::py_install(packages =
# 'umap-learn')
pbmc <- RunUMAP(pbmc, dims = 1:10)
# note that you can set `label = TRUE` or use the LabelClusters function to help label
# individual clusters
DimPlot(pbmc, reduction = "umap")
```

Save the `seurat` object

```{r}
saveRDS(pbmc, file="pbmc3k_tutorial.rds")
```

Save the original `SingleCellExperiment` object, after:

- removing the cells excluded by quality metrics during the Seurat workflow
- adding the cluster assignments
- adding the PCA and t-SNE dimensionality reduction results

```{r}
tenx_pbmc3k <- tenx_pbmc3k[, colnames(pbmc)]
colData(tenx_pbmc3k)[["seurat.ident"]] <- Idents(pbmc)
reducedDim(tenx_pbmc3k, "PCA") <- Embeddings(pbmc, reduction = "pca")
reducedDim(tenx_pbmc3k, "UMAP") <- Embeddings(pbmc, reduction = "umap")
colnames(tenx_pbmc3k) <- NULL # remove the superfluous dummy cell names before exporting
saveRDS(tenx_pbmc3k, file="pbmc3k_tutorial.sce.rds")
```

Export the cluster identity vector.
It will be included in the `r Githubpkg("kevinrue/hancock")` package, and mapped using the dummy cell names defined at the start of this notebook.

```{r}
ident <- Idents(pbmc)
names(ident) <- colnames(pbmc)
saveRDS(ident, "pbmc3k.ident.rds")
```

# See also

- [Applying Gene Signatures to the Seurat PBMC 3k Tutorial](1-proportion_signature.html)
- [Learning Gene Signatures from the Seurat PBMC 3k Tutorial](2-learn-signatures.html)

<button onclick="topFunction()" id="myBtn" title="Go to top">Back to top</button>
